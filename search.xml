<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>没有进程号的进程</title>
    <url>/2023/06/15/%E6%B2%A1%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%8F%B7%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="没有进程号的进程"><a href="#没有进程号的进程" class="headerlink" title="没有进程号的进程"></a>没有进程号的进程</h2><p>某天，苦逼的linux运维小L同学日常巡检线上生产环境过程中发现一个神奇的现象，有一个进程没有名字，也没有进程号。有经验的老鸟很容易联想到真相–<strong>这是个内核进程</strong>，但是小L同学菜啊，哪见过这种场面，<a id="more"></a>一下子有些忐忑起来，以为是自己安全防护不到位，被某些不知名人物入侵了，为了寻求真相，也为了让自己心安，小L同学开始了漫漫探寻之路。</p>
<p>小L同学巡检是查看自己服务器上的elasticsearch进程在不在，于是他是这样做的：</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/%E9%97%AE%E9%A2%98.png" alt=""></p>
<p>小L同学惊悚的发现，第一行的20090端口，没有进程号。于是他下一步试图用ps命令寻找监听这个端口的进程：</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/psef.jpeg" alt=""></p>
<p>很明显，也没有什么发现，于是他觉得这可能是某个僵尸进程所有。由于linux系统中，如果一个进程成为僵尸进程之后，用ps命令查看时，该进程的状态栏会被标记为<strong>defunct</strong>，于是他试图用ps命令查找服务器上的僵尸进程：</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/psaux.png" alt=""></p>
<p>但是很遗憾，还是没有什么发现，甚至通过*<em>lsof -i:port *</em>命令试图查看占用端口中启动的程序也未果。菜鸟运维小L到这里已经用完了他的常规思路，所以开始认真研究了。他先是用telnet命令查看这个端口到死能不能连接，毕竟如此诡异：</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/telnet.png" alt=""></p>
<p>端口是通的，说明有后台是有一个正常进程在处理它，所以小L开始慌张了，他下一步想确认到底是不是某些不知名人物所为。如果是不知名人物所为，那大概了会有网络连接的，所以小L用了ss命令：</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/ss.png" alt=""></p>
<p>还好，通过20090端口只有一个处于ESTAB状态的连接，这是他自己telnet的结果，他稍稍心安。但是这个进程到底是谁建立的呢？小L同学走投无路之下，只好尝试笨办法–直接全局搜索端口号：</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/grep.png" alt=""></p>
<p>还真让他找出来了一些东西，但是很遗憾，这并不是他要的结果，只是服务器上部署的普罗米修斯程序的日志里面有数据刚好匹配上了20090这个字符串。小L同学继续在网络的海洋里游啊游，还真让他找到了一些东西。</p>
<p><strong>rpcinfo</strong>工具可以显示所有使用<strong>portmap</strong>注册的程序的信息。rpcinfo -p x.x.x.x 可以基于rpc协议访问服务器，通过服务器返回的响应信息探测主机x.x.x.x上已经注册的rpc服务的信息。</p>
<p><strong>portmap</strong> 是一个rpc端口映射程序，最初由 Sun 公司开发，它可以将 rpc 程序号映射到网络上的端口号。rpc进程在启动时通知 portmap，显示它们正在监视的端口号以及它们提供服务的 rpc 程序号，然后客户端系统使用特定的 rpc 程序编号联系服务器上的端口映射服务（portmap），然后 portmap 再将客户端重定向到正确的端口号以与其预期的服务进行通信。</p>
<p><img src="https://komo-blog.oss-cn-hangzhou.aliyuncs.com/Blog/2023/06/rpcinfo.png" alt=""></p>
<p>可以看到，让小L同学备受困扰的20090端口赫然在列！但是这个<strong>nlockmgr</strong>服务是个什么呢？</p>
<p>nlockmgr是在NFS中用来管理文件的锁定的，防止多个客户端同时写入某个文件是产生冲突。</p>
<p>NFS服务需要开启 mountd,nfs,nlockmgr,portmapper,rquotad这5个服务，其中nfs、portmapper的端口是固定的，另外三个服务的端口是随机分配的，也可以给mountd,nlockmgr,rquotad设置固定的端口。具体方法很简单，也不再赘述，问问神奇的搜索引擎吧。</p>
]]></content>
      <categories>
        <category>运维经验</category>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>运维经验</tag>
        <tag>linux</tag>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter基本使用与常见性能瓶颈</title>
    <url>/2022/10/23/jmeter%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Jmeter基本使用与常见性能瓶颈"><a href="#Jmeter基本使用与常见性能瓶颈" class="headerlink" title="Jmeter基本使用与常见性能瓶颈"></a>Jmeter基本使用与常见性能瓶颈</h2><h3 id="一、什么是Jmeter"><a href="#一、什么是Jmeter" class="headerlink" title="一、什么是Jmeter"></a>一、什么是Jmeter</h3><p><a href="https://jmeter.apache.org/" target="_blank" rel="noopener">官网链接</a></p>
<p>Apache JMeter 是 Apache 组织基于 Java 开发的压力测试工具，用于对软件做压力测试。<br>JMeter 最初被设计用于 Web 应用测试，但后来扩展到了其他测试领域，可用于测试静态和动态资源，如静态文件、Java <a href="https://baike.baidu.com/item/小服务程序/4148836" target="_blank" rel="noopener">小服务程序</a>、CGI 脚本、Java 对象、数据库和 <a href="https://baike.baidu.com/item/FTP/13839" target="_blank" rel="noopener">FTP</a> 服务器等等。JMeter 可对服务器、网络或对象模拟巨大的负载，<a id="more"></a>在不同压力类别下测试它们的强度和分析整体性能。另外，JMeter 能够对应用程序做功能/<a href="https://baike.baidu.com/item/回归测试/1925732" target="_blank" rel="noopener">回归测试</a>，通过创建带有断言的脚本来验证程序是否返回了期望结果。为了最大限度的灵活性，JMeter 允许<a href="https://baike.baidu.com/item/使用正则表达式/6555484" target="_blank" rel="noopener">使用正则表达式</a>创建断言。</p>
<h3 id="二、Jmeter中的相关概念"><a href="#二、Jmeter中的相关概念" class="headerlink" title="二、Jmeter中的相关概念"></a>二、Jmeter中的相关概念</h3><ol>
<li>线程：一个线程可以理解为一个虚拟用户。比如10个线程表示有10个用户不间断发起请求，也可以理解为<strong>并发数</strong></li>
<li>线程组：测试的起点。一个测试计划必须包含至少一个线程组，其余所有组件都必须在线程组下</li>
<li>监听器：用来查看测试过程中的各项指标</li>
<li>取样器（Sample）是性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元。JMeter 原生支持多种不同的sampler ，如 HTTP Request Sampler 、 FTP  Request Sample 、TCP  Request Sample 、JDBC Request Sampler 等，每一种不同类型的 sampler 可以根据设置的参数向服务器发出不同类型的请求。（<strong>实际上就是配置请求地址和请求参数的地方</strong>）</li>
<li>定时器（Timer）用于操作之间设置等待时间，等待时间是性能测试中常用的控制客户端QPS的手端。类似于LoadRunner里面的“思考时间”。JMeter 定义了Bean Shell Timer、Constant Throughput Timer、固定定时器等不同类型的Timer。</li>
</ol>
<h3 id="三、压力测试过程"><a href="#三、压力测试过程" class="headerlink" title="三、压力测试过程"></a>三、压力测试过程</h3><p>本小节以单一请求为例，描述压力测试设置请求参数、查看测试结果的过程</p>
<ol>
<li>从官网下载jmeter，解压缩</li>
<li>Windows下打开bin/jmeter.cmd</li>
<li>新建测试计划与线程组。打开后默认已建立一个测试计划，右击测试计划根据需要新建线程组，一般选择“setUp Thread Group（常规线程组）”或“Stepping Thread Group（阶梯测试线程组）”</li>
<li>右击线程组根据需要新建取样器（设置请求参数的地方），一般我们是新建HTTP Request</li>
<li>右击线程组，根据需要查看的指标新建监听器，一般结果树（view Result Tree）和聚合报告（Summary Report）是必需的，前者可以看到jmeter发出的每个请求的响应情况，后者可以在生成实时汇总报告</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/f5c9c5f794cc49c99c8aff44b562b334.png#pic_center" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#线程组参数说明</span><br><span class="line">- 线程数： 同时发起的请求数。如线程数为10表示用10个线程模拟10个用户发起请求</span><br><span class="line">- Ramp-Up时间： 多长时间内启动完全部线程</span><br><span class="line">- 循环次数：每个线程循环请求的次数，设置为永远则所有线程持续不间断请求</span><br><span class="line">- 持续时间： 测试请求的时间</span><br><span class="line">- 启动延迟： 单一脚本时用不上。此参数表示当有多个jmeter脚本时，间隔多长时间启动下一脚本</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>因为jmeter图形化界面本身会占用一定资源，为了最大化资源利用效率，jmeter官方也推荐在命令行下进行压力测试，而仅在图形界面设置参数与查看最终结果，因此以上设置完成之后需要保存为jmx文件</p>
</li>
<li><p>将jmx文件与jmeter压缩包一起上传到linux服务器或其他有命令行的地方，执行以下命令开始压测</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmeter -n -t .&#x2F;xxx.jmx -l ..&#x2F;xxx.jtl -e -o ..&#x2F;xxx</span><br><span class="line">#参数说明：</span><br><span class="line">- -n 表示以命令行执行脚本</span><br><span class="line">- -t 指明测试脚本文件的位置（测试脚本文件为jmx文件）</span><br><span class="line">- -l 指明测试结果保存的位置（测试结果文件为jtl文件）</span><br><span class="line">- -e -o 表示同时生成网页报告以及网页文件存放的目录，该目录应为空或不存在</span><br></pre></td></tr></table></figure>
</li>
<li><p>将测试结果文件（jtl文件）拿出来，导入到jmeter图形界面中，查看测试结果；或将网页文件拿出来在网页上查看测试结果</p>
</li>
</ol>
<h3 id="四、测试结果查看"><a href="#四、测试结果查看" class="headerlink" title="四、测试结果查看"></a>四、测试结果查看</h3><ol>
<li>测试过程中的实时查看：</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/3c8cad8b6b23484da23f3cb1e4f2d978.png#pic_center" alt=""></p>
<p>在命令行执行脚本测试过程中，会看到以上页面。</p>
<ul>
<li>“summary +”表示测试过程中的变化量，“summary =”所在的行才是我们需要关注的测试结果，其后跟的数字代表发送请求的数量</li>
<li>in 后面跟的是时间</li>
<li>= 后面跟的是吞吐量，可以近似看作QPS、TPS</li>
<li>Avg、Min、Max 表示请求响应的平均时间、最小时间、最大时间</li>
<li>Err 后面跟的是错误请求的数量与百分比</li>
<li>Active、Started、Finished表示线程数</li>
</ul>
<p>如前三行可以解读为：</p>
<ul>
<li>在前23秒的时候发起了767次请求，TPS为33.3/s，平均响应时间为5724ms，最小响应时间为142ms，最大响应时间为22562ms，此时有0个错误请求，错误请求所占比例为0%，此时启动的线程数是500个，活跃的线程数是500个，已经结束的线程数为0个</li>
<li>在其后的30s內，共发起1212次请求，这30s內TPS为40.4/s，平均响应时间为12531ms，最小响应时间为394ms，最大响应时间为49573ms，此过程中共有0个错误请求，错误请求所占比例为0%，此时启动的线程数是500个，活跃的线程数是500个，已经结束的线程数为0个</li>
<li>总结以上，在前53s时间内，共发起1979次请求，TPS为37.3，平均响应时间为9893ms，最小响应时间为142ms，最大响应时间为49573ms，此时有0个错误请求，错误请求所占比例为0%，此时启动的线程数是500个，活跃的线程数是500个，已经结束的线程数为0个</li>
</ul>
<ol start="2">
<li><p>测试结束后将结果文件（jtl文件）导入到jmeter图形界面：</p>
<p>结果树：<br><img src="https://img-blog.csdnimg.cn/fb7549fb276b40f28d6b786687f7d759.png#pic_center" alt=""></p>
<p>结果树可以看到每个请求的响应情况</p>
<p>聚合报告：</p>
<p><img src="https://img-blog.csdnimg.cn/c589751702a7418f80f306053020509d.png#pic_center" alt=""></p>
<p>聚合报告可以看到发起的总请求数、平均响应时间、响应时间的中位数、90%的请求在多长时间内完成响应、95%的请求在多长时间内完成响应、99%的请求在多长时间内完成响应、响应时间的最大值、响应时间的最小值、异常请求所占的比例、吞吐量（TPS）以及发送、接受数据的速度</p>
</li>
</ol>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li><p>如果调整参数每次都在图形界面进行，对于我们在命令行进行测试十分不方便，我们可以直接修改jmx文件实现参数调整，如果线程组使用的是“setUp Thread Group”，那么可以在jmx文件中全局搜索“setUp”关键字，找到以下内容修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;SetupThreadGroup guiclass&#x3D;&quot;SetupThreadGroupGui&quot; testclass&#x3D;&quot;SetupThreadGroup&quot; testname&#x3D;&quot;setUp Thread Group&quot; enabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;stringProp name&#x3D;&quot;ThreadGroup.on_sample_error&quot;&gt;continue&lt;&#x2F;stringProp&gt;</span><br><span class="line">        &lt;elementProp name&#x3D;&quot;ThreadGroup.main_controller&quot; elementType&#x3D;&quot;LoopController&quot; guiclass&#x3D;&quot;LoopControlPanel&quot; testclass&#x3D;&quot;LoopController&quot; testname&#x3D;&quot;Loop Controller&quot; enabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">          &lt;boolProp name&#x3D;&quot;LoopController.continue_forever&quot;&gt;false&lt;&#x2F;boolProp&gt;</span><br><span class="line">          &lt;intProp name&#x3D;&quot;LoopController.loops&quot;&gt;-1&lt;&#x2F;intProp&gt;</span><br><span class="line">        &lt;&#x2F;elementProp&gt;</span><br><span class="line">        &lt;stringProp name&#x3D;&quot;ThreadGroup.num_threads&quot;&gt;200&lt;&#x2F;stringProp&gt;        &lt;!--线程数--&gt;</span><br><span class="line">        &lt;stringProp name&#x3D;&quot;ThreadGroup.ramp_time&quot;&gt;1&lt;&#x2F;stringProp&gt;            &lt;!--多长时间内启动所有线程--&gt;</span><br><span class="line">        &lt;boolProp name&#x3D;&quot;ThreadGroup.scheduler&quot;&gt;true&lt;&#x2F;boolProp&gt;</span><br><span class="line">        &lt;stringProp name&#x3D;&quot;ThreadGroup.duration&quot;&gt;120&lt;&#x2F;stringProp&gt;           &lt;!--测试持续时间--&gt;</span><br><span class="line">        &lt;stringProp name&#x3D;&quot;ThreadGroup.delay&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">        &lt;boolProp name&#x3D;&quot;ThreadGroup.same_user_on_next_iteration&quot;&gt;false&lt;&#x2F;boolProp&gt;</span><br><span class="line">      &lt;&#x2F;SetupThreadGroup&gt;</span><br></pre></td></tr></table></figure>

   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;HTTPSamplerProxy guiclass&#x3D;&quot;HttpTestSampleGui&quot; testclass&#x3D;&quot;HTTPSamplerProxy&quot; testname&#x3D;&quot;HTTP Request&quot; enabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">          &lt;elementProp name&#x3D;&quot;HTTPsampler.Arguments&quot; elementType&#x3D;&quot;Arguments&quot; guiclass&#x3D;&quot;HTTPArgumentsPanel&quot; testclass&#x3D;&quot;Arguments&quot; testname&#x3D;&quot;User Defined Variables&quot; enabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;collectionProp name&#x3D;&quot;Arguments.arguments&quot;&#x2F;&gt;</span><br><span class="line">          &lt;&#x2F;elementProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.domain&quot;&gt;x.x.x.x&lt;&#x2F;stringProp&gt;        &lt;!--请求地址--&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.port&quot;&gt;xxxx&lt;&#x2F;stringProp&gt;                &lt;!--请求端口--&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.protocol&quot;&gt;http&lt;&#x2F;stringProp&gt;            &lt;!--请求协议--&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.contentEncoding&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.path&quot;&gt;&#x2F;xxxx&lt;&#x2F;stringProp&gt;             &lt;!--请求路径--&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.method&quot;&gt;GET&lt;&#x2F;stringProp&gt;                 &lt;!--请求方式--&gt;</span><br><span class="line">          &lt;boolProp name&#x3D;&quot;HTTPSampler.follow_redirects&quot;&gt;true&lt;&#x2F;boolProp&gt;</span><br><span class="line">          &lt;boolProp name&#x3D;&quot;HTTPSampler.auto_redirects&quot;&gt;false&lt;&#x2F;boolProp&gt;</span><br><span class="line">          &lt;boolProp name&#x3D;&quot;HTTPSampler.use_keepalive&quot;&gt;true&lt;&#x2F;boolProp&gt;</span><br><span class="line">          &lt;boolProp name&#x3D;&quot;HTTPSampler.DO_MULTIPART_POST&quot;&gt;false&lt;&#x2F;boolProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.embedded_url_re&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.connect_timeout&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;HTTPSampler.response_timeout&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">        &lt;&#x2F;HTTPSamplerProxy&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要测试存储服务或其他下载服务，可以选中当前线程组，右键添加后置处理程序-》BeanShell PostProcessor，加入以下脚本：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"> </span><br><span class="line">import java.util.UUID;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;获取上个请求的返回数据</span><br><span class="line"> </span><br><span class="line">byte[] result &#x3D; prev.getResponseData();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;要下载到什么地方</span><br><span class="line"> </span><br><span class="line">String file_name &#x3D; &quot;\\apps\\temp\\downloads\\&quot;+UUID.randomUUID().toString()+&quot;.jpg&quot;;</span><br><span class="line"> </span><br><span class="line">File file &#x3D; new File(file_name);</span><br><span class="line"> </span><br><span class="line">FileOutputStream out &#x3D; new FileOutputStream(file);</span><br><span class="line"> </span><br><span class="line">out.write(result);</span><br><span class="line"> </span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>

<p>或直接在jmx文件中与”ResultCollector“平级的层加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;BeanShellPostProcessor guiclass&#x3D;&quot;TestBeanGUI&quot; testclass&#x3D;&quot;BeanShellPostProcessor&quot; testname&#x3D;&quot;BeanShell PostProcessor&quot; enabled&#x3D;&quot;true&quot;&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;filename&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;parameters&quot;&gt;&lt;&#x2F;stringProp&gt;</span><br><span class="line">          &lt;boolProp name&#x3D;&quot;resetInterpreter&quot;&gt;false&lt;&#x2F;boolProp&gt;</span><br><span class="line">          &lt;stringProp name&#x3D;&quot;script&quot;&gt;import java.io.*;</span><br><span class="line"> </span><br><span class="line">import java.util.UUID;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;获取上个请求的返回数据</span><br><span class="line"> </span><br><span class="line">byte[] result &#x3D; prev.getResponseData();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;要下载到什么地方</span><br><span class="line"> </span><br><span class="line">String file_name &#x3D; &quot;\\apps\\temp\\downloads\\&quot;+UUID.randomUUID().toString()+&quot;.jpg&quot;;</span><br><span class="line"> </span><br><span class="line">File file &#x3D; new File(file_name);</span><br><span class="line"> </span><br><span class="line">FileOutputStream out &#x3D; new FileOutputStream(file);</span><br><span class="line"> </span><br><span class="line">out.write(result);</span><br><span class="line"> </span><br><span class="line">out.close();&lt;&#x2F;stringProp&gt;</span><br><span class="line">        &lt;&#x2F;BeanShellPostProcessor&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="五、常见的性能瓶颈"><a href="#五、常见的性能瓶颈" class="headerlink" title="五、常见的性能瓶颈"></a>五、常见的性能瓶颈</h3><ul>
<li>网络带宽（尤其是压测请求的请求体或响应体较大的时候尤为明显）</li>
<li>磁盘IO（与之相关的是nginx、程序的日志级别）</li>
<li>JVM参数</li>
<li>网络参数（/etc/ sysctl.conf）</li>
</ul>
]]></content>
      <categories>
        <category>运维工具</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>运维工具</tag>
        <tag>压力测试</tag>
      </tags>
  </entry>
  <entry>
    <title>程序中的数据类型转换</title>
    <url>/2022/10/17/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h3><ul>
<li>short</li>
<li>int</li>
<li>long</li>
<li>long long （short &lt;= int &lt;= long &lt;= long long）</li>
<li>float</li>
<li>double</li>
<li>long double</li>
<li>char：一个char类型的大小跟一个机器字节一样（与机器有关）</li>
<li>unsigned （各种无符号数 &gt;= 0，循环条件需注意）</li>
<li>bool</li>
</ul>
<h3 id="程序类型选择的原则"><a href="#程序类型选择的原则" class="headerlink" title="程序类型选择的原则"></a>程序类型选择的原则</h3><ul>
<li>明确知晓数值不可能为负数时，选用无符号类型<a id="more"></a></li>
<li>使用int执行整数运算（short太小，long跟int 一样；若整数超出int表示范围，选long long）</li>
<li>在算术表达式中不要使用 char 或 bool，只有在存放字符或布尔值时才使用它们。因为类型 char在一些机器上是有符号的，而在另一些机器上又是无符号的， 所以如果使用 char 进行运算特别容易出问题。如果需要使用一个不大的整数， 那么明确指定它的类型是 Signed char 或者 uns igned char</li>
<li>执行浮点数运算选用 double，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的， 沉且它带来的运行时消耗也不容忽视</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为0则结果为 false, 否则结果为 true</li>
<li>当我们把一个布尔值赋给非布尔类型时，初始值为 false则结果为0，初始值为 true 则结果为1</li>
<li>当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分</li>
<li>当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失</li>
<li>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的 unsigned char 可以表示0至 255 区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对 256 取模后所得的余数。因此，把-1赋给＆比特大小的 unsigned char 所得的结果是255</li>
<li>当我们赋给带符号类型一个超出它表示范围的值时，结果是末定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据</li>
</ul>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li>当一个算数表达式中既有无符号数又有int值时，那么int值就会转换成无符号数。int型转无符号数的过程与把int值直接赋给无符号变量一样：把负数转换为无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模</li>
<li>无符号数永远不小于0，无符号数用于循环中需注意</li>
</ul>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础-main函数返回值问题</title>
    <url>/2022/04/19/main%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="C-基础-main函数返回值问题"><a href="#C-基础-main函数返回值问题" class="headerlink" title="C++基础-main函数返回值问题"></a>C++基础-main函数返回值问题</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在从头学习C++  ”圣经“ —-《C++ Primer》时看到一个思考题 ”返回值 -1 通常作为程序错误的标识，当程序的 main 函数返回值为 -1 时，观察系统如何处理返回的错误标识“，编写程序验证：<a id="more"></a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"sssss"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行之后使用 ”echo $?“ 观察系统接收到的返回值，发现为255。还在纳闷这个值从何而来，实在惭愧一时没想起来<strong>计算机采用补码形式存储数据</strong>，特此记录</p>
<h3 id="计算机基础-数字的表示方法"><a href="#计算机基础-数字的表示方法" class="headerlink" title="计算机基础-数字的表示方法"></a>计算机基础-数字的表示方法</h3><p>计算机中有符号整数有三种表示方法——-原码、反码、补码。</p>
<ul>
<li><p>原码：第一位表示符号位，后面为有符号整数绝对值的二进制形式</p>
</li>
<li><p>反码：有符号正整数的反码等于原码；负整数的反码为第一位符号位不变，其后每一位变成相反数</p>
</li>
<li><p>补码：有符号正整数的补码等于原码；负整数的补码为反码+1</p>
<p><strong>总结：</strong></p>
<p><strong>有符号正整数原码=反码=补码</strong></p>
<p><strong>有符号负整数反码等于原码除符号位不变外，其余每一位取反；补码等于原码除符号位不变外，其余每一位取反再加1</strong></p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十进制-----------------二进制原码-------------反码-----------------补码</span><br><span class="line">  9                   0000 1001          0000 1001           0000 1001</span><br><span class="line"> -9                   1000 1001          1111 0110           1111 0111</span><br><span class="line"> 127                  0111 1111          0111 1111           0111 1111</span><br><span class="line">-127                  1111 1111          1000 0000           1000 0001</span><br><span class="line"> 128                  1000 0000          1000 0000           1000 0000</span><br><span class="line">-128             0001 1000 0000     0001 0111 1111      0001 1000 0000</span><br></pre></td></tr></table></figure>

<h3 id="C-基础-main函数返回值问题-1"><a href="#C-基础-main函数返回值问题-1" class="headerlink" title="C++基础-main函数返回值问题"></a>C++基础-main函数返回值问题</h3><p>回到main函数的返回值问题，为何显示255？</p>
<p>因为<strong>系统用8bits的无符号数标识退出状态，所以退出的状态值为0至255</strong>，而有符号整型 -1 的补码形式为 1111 1111 对应无符号整型为 255</p>
<p>那么问题来了，既然系统的退出状态值为8bits的无符号数，取值范围就是0-255，如果我在函数里面返回了超255的数又会怎样呢？很简单，返回的值会被<strong>截断</strong></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果main函数最终return 257;</span><br><span class="line">257：</span><br><span class="line">二进制原码&#x3D;反码&#x3D;补码：0000 0001 0000 0001</span><br></pre></td></tr></table></figure>

<p>那么，系统会截取最低8bits，即 0000 0001 ,最终编译运行之后再”echo $?“ 得到的值就是 1</p>
]]></content>
      <categories>
        <category>C++基础</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
        <tag>计算机基础</tag>
        <tag>数字的表示方法</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器SSH被字典爆破时记录密码</title>
    <url>/2020/11/10/%E6%9C%8D%E5%8A%A1%E5%99%A8SSH%E8%A2%AB%E5%AD%97%E5%85%B8%E7%88%86%E7%A0%B4%E6%97%B6%E8%AE%B0%E5%BD%95%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="服务器SSH被字典爆破时记录对方使用的密码"><a href="#服务器SSH被字典爆破时记录对方使用的密码" class="headerlink" title="服务器SSH被字典爆破时记录对方使用的密码"></a>服务器SSH被字典爆破时记录对方使用的密码</h2><p>事情的起因是这样的：本人购（bai）买（piao）了一台华为云的云主机，有一天登录的时候日常查看安全日志，发现有人在用字典爆破我ssh登录的用户名和密码，奈何我早就做了安全加固（更改ssh端口、禁止root用户登录、使用fail2ban）对方并没有成功。由于我端口选的过于随机，用户名足够偏，密码强度足够，便放任他爆破。过了一个月发现还在继续，感叹对方执着的同时突然想到：这不正是一个构建自己密码字典的好机会吗？瞬间感觉自己错过了一个亿……<a id="more"></a>迄今为止对方可是已经尝试了四十多万次了啊！！！！于是动手开始部署，准备记录。<br><img src="../../../../../../image/2020/11/10/fail2ban.png" alt="执着的爆破者"></p>
<p>在网上找到了两种方法：一种是通过patch，也就是打补丁的方式。因为默认的ssh日志是不带密码记录功能的，于是可以重新编译openssh并打上补丁，使它能够记录，但尝试之后这种方法并没有成功，因为在打补丁的过程中报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch --dry-run &lt; syslog.patch</span><br><span class="line">checking file auth-passwd.c </span><br><span class="line">patch: **** malformed patch at line 4: &#123;</span><br></pre></td></tr></table></figure>

<p>我对这方面不是很了解，也没有找到解决方法，遂放弃。</p>
<p>另一种方法是使用docker部署ssh蜜罐记录下爆破密码。但尝试之后发现效果不是很理想，因为对方并不仅仅针对单一端口进行爆破，而是不断变换爆破端口。这就导致docker端口与主机端口间的映射出现问题。举个例子：当docker的22端口映射主机的22端口时，对方如果针对22端口进行爆破，肯定能记录下密码，但要是对方针对33端口进行爆破呢？遂放弃。兜兜转转终于找到如下方法：</p>
<h5 id="主机环境：Centos-7"><a href="#主机环境：Centos-7" class="headerlink" title="主机环境：Centos 7"></a>主机环境：Centos 7</h5><p>1、到官网下载源码包(可以先去官网看看最新版本的版本号)<br><code>wget https://mirror.leaseweb.com/pub/OpenBSD/OpenSSH/portable/openssh-8.4p1.tar.gz</code></p>
<p>2、创建配置文件目录(也可以使用默认目录，下文中configure命令完成时会显示配置文件目录以及安装目录)<br><code>sudo mkdir -p /usr/local/ssh8.4p1/conf</code></p>
<p>3、安装依赖环境<br><code>sudo yum install gcc zlib-devel openssl-devel -y</code></p>
<p>4、解压之前下载的源码包<br><code>tar -zxvf openssh-8.4p1.tar.gz</code></p>
<p>5、修改源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进入解压目录</span><br><span class="line">cd .&#x2F;openssh-8.4p1</span><br><span class="line"></span><br><span class="line">#编辑auth-passwd.c文件</span><br><span class="line">vim .&#x2F;auth-passwd.c</span><br><span class="line"></span><br><span class="line">#找到函数auth_password，添加以下代码</span><br><span class="line">logit(&quot;username: %s password: %s&quot;, authctxt-&gt;user, password);</span><br></pre></td></tr></table></figure>

<p><img src="../../../../../../image/2020/11/10/auth-passwd.png" alt="修改后的源码"></p>
<p>6、编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#编译</span><br><span class="line"> .&#x2F;configure --sysconfdir&#x3D;&#x2F;usr&#x2F;local&#x2F;ssh8.4p1&#x2F;conf&#x2F; --without-zlib-version-check --with-md5-passwords --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;ssh8.4p1&#x2F;</span><br><span class="line"></span><br><span class="line">#参数说明</span><br><span class="line">--sysconfdir #配置文件目录</span><br><span class="line">--without-zlib-version-check</span><br><span class="line">--with-md5-passwords</span><br><span class="line">--prefix #安装目录</span><br><span class="line"></span><br><span class="line">(Ps:此命令完成时会显示配置文件位置和安装位置，后面需要用到配置文件位置)</span><br><span class="line"></span><br><span class="line">#make &amp;&amp; make install</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>7、登录测试，查看日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改配置文件</span><br><span class="line">sudo vim &#x2F;usr&#x2F;local&#x2F;ssh8.4p1&#x2F;conf&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line">#修改ssh端口</span><br><span class="line">Port 1234</span><br><span class="line"></span><br><span class="line">#禁止root用户登录</span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line">#启动(必须使用绝对路径，这跟ssh服务自身有关)</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;ssh8.4p1&#x2F;sbin&#x2F;sshd</span><br><span class="line">#如果启动失败请查看之前是否有安装openssh</span><br><span class="line"></span><br><span class="line">#连接（如果连接不上请检查防火墙，查看端口是否开放）</span><br><span class="line">ssh -p 1234 xxx@xxx.xxx.xxx.xxx</span><br><span class="line"></span><br><span class="line">#查看日志</span><br><span class="line">sudo grep username &#x2F;var&#x2F;log&#x2F;secure</span><br></pre></td></tr></table></figure>

<p><img src="../../../../../../image/2020/11/10/log.png" alt="效果"><br>可以看到显示结果还是不够纯粹，还有一些其他信息，如果想要看到更纯粹的显示内容，可以再次利用管道符和grep进行过滤<br><code>sudo grep username /var/log/secure | grep password | grep sshd</code></p>
<p>（Ps：这里顺便记录一下，管道符的作用是将管道符前命令的输出作为管道符后命令的输入）</p>
<h5 id="到这里爆破密码的记录已经完成，要想构建自己的密码字典还得将密码提取出来"><a href="#到这里爆破密码的记录已经完成，要想构建自己的密码字典还得将密码提取出来" class="headerlink" title="到这里爆破密码的记录已经完成，要想构建自己的密码字典还得将密码提取出来"></a>到这里爆破密码的记录已经完成，要想构建自己的密码字典还得将密码提取出来</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#首先新建保存密码的文件</span><br><span class="line">touch .&#x2F;dir.txt</span><br><span class="line"></span><br><span class="line">#使用grep与awk将内容提取出来</span><br><span class="line">sudo cat &#x2F;var&#x2F;log&#x2F;secure | grep -v &#39;你的用户名&#39; | grep -v &#39;你的密码&#39; | grep &#39;password:&#39; |grep &#39;username:&#39; |grep &#39;sshd&#39;| awk -F &#39; &#39; &#39;&#123;print $7,$9&#125;&#39;&gt;&gt;dir.txt</span><br></pre></td></tr></table></figure>

<p>管道符‘|’就像一道滤筛有木有……每使用一次就将结果过滤一次<br>grep的-v选项是反向选择，所有包含指定字符串的记录都将被过滤掉，因为日志文件中肯定包含了你自己登录的正确用户名和正确密码，你一定不想要自己的密码流出去是不是，毕竟只有自己知道的密码才相对安全嘛</p>
<p>awk命令的-F选项表示以何种符号分割， $n表示第n个参数(分割后的第n个参数)，我这里使用“ ”也即是空格符进行分割</p>
<p>注意结尾 “&gt;&gt;dir.txt” 那里一定是两个”&gt;”,因为“&gt;”重定向输出时会覆盖文件中原有的内容，而“&gt;&gt;”则是会将内容追加在文件已有内容末尾</p>
<p>我这里不仅提取了密码，还顺便提取出了用户名，后续可以根据需要进行再次加工</p>
<h5 id="至此密码也已经提取出来了"><a href="#至此密码也已经提取出来了" class="headerlink" title="至此密码也已经提取出来了"></a>至此密码也已经提取出来了</h5><p>但是对方还在持续爆破，作为一名运维人员，我怎么可能定期手动执行上述命令提取密码？当然要自动化啦！</p>
<h5 id="自动化提取密码"><a href="#自动化提取密码" class="headerlink" title="自动化提取密码"></a>自动化提取密码</h5><p>将命令转化为脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#新建dir.sh并写入如下内容：</span><br><span class="line">vim .&#x2F;dir.sh</span><br><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;zsh</span><br><span class="line">cat &#x2F;var&#x2F;log&#x2F;secure | grep -v &#39;你的用户名&#39; | grep -v &#39;你的密码&#39; | grep &#39;password:&#39; |grep &#39;username:&#39; |grep &#39;sshd&#39;| awk -F &#39; &#39; &#39;&#123;print $7,$9&#125;&#39;&gt;&gt;dir.txt</span><br><span class="line"></span><br><span class="line">#给脚本赋予可执行权限</span><br><span class="line">sudo chmod +x .&#x2F;dir.sh</span><br></pre></td></tr></table></figure>

<p>要想实现上述命令的自动化，有两个要点：</p>
<ul>
<li>root权限执行脚本</li>
<li>定时执行脚本</li>
</ul>
<p>因为上述命令需要root权限才能执行，写成脚本之后自然也需要root权限。在网上查找之后选择expect。其原理也就是在输入su命令之后由expect自动填写密码</p>
<p><code>sudo yum install expect</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#新建auto.sh并写入如下内容：</span><br><span class="line">vim .&#x2F;auto.sh</span><br><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;expect</span><br><span class="line">spawn su root</span><br><span class="line">expect &quot;Password:&quot;</span><br><span class="line">send &quot;你的密码\r&quot;</span><br><span class="line">send &quot;cd 脚本所在目录\r&quot;</span><br><span class="line">send &quot;.&#x2F;dir.sh\r&quot;</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">exit     </span><br><span class="line"></span><br><span class="line">#给脚本赋予可执行权限</span><br><span class="line">sudo chmod +x .&#x2F;auto.sh</span><br></pre></td></tr></table></figure>

<p>至此第一个问题解决了，第二个问题也很好解决。Linux中crontab是用来定期执行程序的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#新建定时任务</span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">#输入如下</span><br><span class="line">0 0 *&#x2F;3 * * auto.sh脚本所在位置的绝对路径&#x2F;auto.sh</span><br><span class="line"></span><br><span class="line">#查看定时任务是否创建成功</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>上述命令的意思是每隔三天，在零点零分的时候定期执行auto.sh脚本（crontab命令的具体用法可自行百度或google）</p>
<p>新建任务格式详解（/etc/crontab）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line"># Example of job definition:</span><br><span class="line"># .---------------- minute (0 - 59)</span><br><span class="line"># |  .------------- hour (0 - 23)</span><br><span class="line"># |  |  .---------- day of month (1 - 31)</span><br><span class="line"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"># |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></table></figure>

<p>至此全部过程就结束了，接下来就可以等着自己密码字典的成型啦！！！！</p>
]]></content>
      <categories>
        <category>服务器安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>服务器安全</tag>
        <tag>SSH</tag>
        <tag>字典爆破</tag>
      </tags>
  </entry>
  <entry>
    <title>About</title>
    <url>/2020/07/24/About/</url>
    <content><![CDATA[<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>  ——初来乍到，请多关照（^_^）—–</p>
<p>21考研狗一枚，想通过写博客的方式将所学的东西复述出来，加深理解。同时，被各路大神博客拯救过无数次的我深知一篇浅显易懂博客的重要性，所以我自己也想从一个索取者变成一个分享者，希望能帮到大家。<a id="more"></a>备考期间不定时更新（其实是不想复习了就更新hahahhahaha），内容随缘。可能是技术类文章，也可能是读后感、感悟之类的。备考期间会着重复习数据结构、算法、C++，刷力扣之类的，所以未来一段时间可能算法类多一点。另外，会抽空看一点系统介绍Linux的电子书（虽然Linux是我目前的主系统，但不得不说，我对它缺乏系统性的了解，很难深入….）。考试之后有想法入坑CTF（其实是想入坑很久了，苦于….），到时候也会更新自己的学习感悟。</p>
<p>如果有大神发现我的博客有误，可以通过以下方式联系我改正，万分感激：</p>
<ul>
<li>email:<a href="mailto:komorebilzh@gmail.com">komorebilzh@gmail.com</a></li>
<li>QQ:3360207672</li>
<li>twitter:<a href="https://twitter.com/messages" target="_blank" rel="noopener">→_→</a></li>
</ul>
<p>———-THE END———</p>
]]></content>
      <categories>
        <category>about</category>
      </categories>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
</search>
